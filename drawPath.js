 // var path = "M477.38,230.73c11.47-3.27,44.58-14.46,49.81-15.3,19.74-3.17,41,3,55.14,16.12,4.08,3.78,12.23,23.54,12.69,28.88,1.42,16.42,7.38,32.84,8.81,49.26,1.77,20.45-1.73,37.78-10.2,56.74-4.31,9.66-15.33,20.88-24.25,27.32-5.68,4.1-12.39,6.82-19.19,9.05-39.48,12.94-82.63,12-124.53,11.57-15.84-.15-32,.12-47,5-22,7.17-45.47,8.5-68.64,10.83s-85.78,6.34-98.11-43.51c-9.72-39.31,38.49-89.26,7.66-139.27-7.87-12.76-34-35-27.68-55.13,2.51-8,13.36-13.59,21.83-14.36,34.8-3.19,67.93,54.77,140.11,53.23C399.92,230.17,438.21,241.88,477.38,230.73Z" //transform="translate(-190.48 -177.29)"
var triangle="M98.31,214.85l-1.48-2.57L96,210.87l-1.48-2.55-1.88,3.26-1.89,3.27h7.54Z"// transform="translate(-70.59 -184.02)"/><path class="cls-1"
var star="M80.85,210.45l-1.17,1.13-1.13,1.11.26,1.53.28,1.63-2.84-1.49-2.83,1.49.3-1.74.24-1.42-2.3-2.24,2-.29,1.18-.17.9-1.83.51-1,.6,1.21.82,1.67Z" 	
var circle="M114.31,214.94l1-1.75.91-1.59-1.07-1.86-.85-1.47h-3.85l-.89,1.55-1,1.78.85,1.49,1.07,1.85h3.85Z"  
	
var  path1 ="M749,356c18.38-16.44,48.88-21.6,70.28-9.35,20.43,11.68,25.53,39.12,23.07,62.53s-10.21,46.71-6.8,70c2.81,19.17-9.86,71.72-23,86-32.81,35.75-82.55,52.58-203.93,78.91-75.81,16.45-108,11.2-164.27-.34-37.4-7.67,22.72-45.92,19.45-83.72-2.47-28.6,9.1-56.64,29.75-76.56s46.88-33,73.1-44.63C613.91,417.83,713.77,387.55,749,356Z"
// transform="translate(-190.01 -85.38)"/><path class="cls-1" 

var path2 = 
"M776.07,343.58c8.56-5.38,22.12-5.33,31.52-1.59,11.72,4.68,22.79,16.73,27.48,25.69,7.91,15.15,1.13,33.51,4.5,50.27,14.4,71.57-11.86,141.12-19.74,155.94C789.37,631.14,601,680.55,445.09,658.74c-46.36-6.48-128-40.28-165-68.93C242.3,560.54,199.4,480.32,192.34,457c-14.74-48.86,44-47.93,77.26-78.68,30.25-28,71.29-42,112.24-46.67s82.32-.55,123.32,3.52c43.26,4.29,88.94,18.95,132.2,23.25C683.91,363,736.44,368.45,776.07,343.58Z" 

//transform="translate(-190.01 -85.38)"/><path class="cls-2"
 var path3 ="M794.35,339.56c-11.69,1.2-20.79,13.91-18.14,25.35,1.5,6.48,6,11.91,11.38,15.88s11.46,6.71,17.44,9.62A141.71,141.71,0,0,1,829.54,405c25,19.17,39.52,50.21,66.29,66.8,8,4.93,29.1,14.08,52,17.52,12.72,1.91,61.91.88,73.4-1.31,21.91-4.17,41.52-13.95,60.54-25.6,8.57-5.25,37-25.77,42.79-30.6,7.67-6.42,35-29.37,40.3-35.17,11.61-12.79,23-25.8,32.51-40.24A70.32,70.32,0,0,0,1208,329.23a22.17,22.17,0,0,0,0-9,24.38,24.38,0,0,0-4.06-7.83,157.82,157.82,0,0,0-48.17-44.87c-7.75-4.63-80.28-39.9-92.14-44.27-20-7.35-41-11.31-61.91-14.92-30.65-5.28-91.52-1.1-112.7,14.76-20.51,15.37-35.92,36.68-49.27,58.55C826.81,303,819.13,337,794.35,339.56Z" 

//transform="translate(-190.01 -85.38)"/><path class="cls-3" 
var path3 ="M692.41,159.86c-13.85-8.53-71.12-46-86.71-55.13-33.14-19.45-73.69-20.15-112.1-19-13.61.4-27.43,1-40.37,5.25-25.08,8.23-44,29.19-57.9,51.6s-24.23,47-39.2,68.75c-3.15,4.56-6.66,9.61-5.92,15.11s5.58,9.51,10,12.89l29,21.91c26.31,19.89,53.48,40.2,85.31,48.8,26.29,7.1,48,10.61,75.12,13.28,26.05,2.56,63.29-8.3,74.14-12.71,35.32-14.36,68.67-33.09,101.91-51.76,12-6.75,45-17.81,48.58-32.84C776.42,217.06,709.67,170.49,692.41,159.86Z" 

//transform="translate(-190.01 -85.38)"/><path class="cls-4" 
var path4 ="M786.28,501.18c-9.4-5-33.41-22.6-37.34-47.56-5.3-33.63,2.74-48.62,15.76-80.08,3.82-9.24,8.67-18.26,15.84-25.22s16-7.71,25.94-7.13c14.87.88,27.79,26.72,22.63,40.7-15.94,43.2,10,34.83,4.14,77.53C830.4,480.06,810.53,514,786.28,501.18Z"// transform="translate(-190.01 -85.38)"/></svg>

var fillColors=["#568d99","#74b59b","#e0a926","#da4c27"]
var panel = 0    
var currentScrollTop = d3.select('#currentScrollTop')
var panelSize =500//window.innerHeight

var width = 1400
var height = 1000
var margin = 20
var networkGrid = 70
var line = d3.line()
// Create the SVG
var nodeCoordsDictionary
var nodeData = null
var linkData = null


var scrollTop = 0
var newScrollTop = 0

var svg = d3.select("#network").append("svg").attr("width",width).attr("height",height)
  
Promise.all([d3.csv("network_data_nodes.csv"),d3.csv("network_data_links.csv")])
    .then(function(data){
		console.log(data[0])
		
	 nodeCoordsDictionary = nodeDictionary(data[0])
	  links = data[1]
		linkData = data[1]
	  drawLinks(links,nodeCoordsDictionary)
	   nodeData =data[0]
		drawNodes(data[0])      //
	  d3.selectAll("text").style("opacity",0)
		
		
		for(var i in nodeData){
			
			if(nodeData[i].label!=undefined){
				var chapterPanel = d3.select("#content").append("div").attr("class","panel")
				.attr("id","panel_"+i)
				.style("height",(panelSize-100)+"px")
				.style("width","300px")
				.style("padding","20px")
				.style("padding-top","80px")
				.style("font-size","14px")
				.style("position","relative")
				.style("margin-left","1000px")
				//.attr("id","panel_"+cleanString(nodeData[i].label))
				var panelTitle = chapterPanel.append("div").attr("class","panelTitle").html(nodeData[i].label)
				.style("padding","20px")
				.style("font-size","24px")
				
				var panelContent = chapterPanel.append("div").attr("class","panelContent")
				.style("padding","20px")
				.style("border","1px dotted black")
				.style("background-color","rgba(255,255,255,.8)")

				panelContent.html(nodeData[i].notes)
			}
		}
		
        //set the public variable publicData to our dataset that was just loaded, now it is available for any function outside of this promise
        //publicData = data[0]//remember that even if we load just 1 dataset this way, it is still in an array of length 1
	  //  blobs(path1);
      //  drawBarChart()
        // step0()

      // blobs(path1,"path1");
      // blobs(path2,"path2");
      // blobs(path3,"path3");
      // blobs(path4,"path4");
})
	
function nodeDictionary(data){
	var formatted ={}
	for(var i in data){
		if(data[i].label!=undefined){
			var key = cleanString(data[i].label)
			var coords = [parseInt(data[i].x),parseInt(data[i].y)]
			var chapter = data[i].chapter
			formatted[key]={coords:coords,chapter:chapter}
		}
	}
	return formatted
}

function cleanString(string){
	var string = string.replace(/[^\w\s]/gi, '')
	return string.split(" ").join("").split("%").join("")
}
	

function drawLinks(links,nodes){
	var linkPath = d3.line().curve(d3.curveBasis)	
	var cellSize =  networkGrid 
	
	// console.log(links)
// 	console.log(nodes)
	for(var l in links){
		var link = links[l]
		var source = link.source
		var target = link.target
		if(source!=undefined && target!=undefined){
		//console.log(source,cleanString(target))
			var sourceCoords = nodes[cleanString(source)].coords
			var targetCoords = nodes[cleanString(target)].coords
			// console.log([target])
// 			console.log(nodes)
// 			console.log(targetCoords)
			var lineData = [[sourceCoords[0]*cellSize,sourceCoords[1]*cellSize],[targetCoords[0]*cellSize,targetCoords[1]*cellSize]]
			
			
		//	console.log(lineData)
			var path = svg//.append("g")//.selectAll("#_"+cleanString(source)+"_"+cleanString(target))
			.append("path")
			.attr("id","_"+cleanString(source)+"_"+cleanString(target))
			.attr("d",function(){
 					return linkPath(lineData)
			})
			.attr('stroke', "black")
			
			var pathLength = path.node().getTotalLength();			
			path.attr("pathLength",pathLength)
			//.attr("stroke-dasharray", pathLength + " " + pathLength)
			.attr("stroke-dasharray",pathLength+" "+pathLength)//pathLength + " " + pathLength)
			.attr("stroke-dashoffset",pathLength)
		}
	}
}
function drawNodes(data){
	//console.log(data)
	var cellSize =  networkGrid
	
	svg.selectAll(".nodes")
	.data(data)
	.enter()
	.append("text")
	.style("font-size","12px")
	.text(function(d){
		if(d.type=="blank"){
			return ""
		}else{
			return d.label
		}
	})
	.attr("x",function(d){
		return d.x*cellSize
	})
	.style("text-anchor","middle")
	.attr("y",function(d){
		return d.y*cellSize+3
	})
	.style("stroke","rgba(255,255,255,1)")
	.style("stroke-width","8px")
	.style("font-size",function(d){
		if(d.label=="Ghayour"){//}||d.label=="Elizabeth Rubin"){
			return "18px"
		}else if(d.type=="group"){
			return "18px"
		}
		else if(d.type=="city"){
			return "24px"
		}
	})
	.style("font-style",function(d){
		if(d.type=="group"){
					return "italic"
				}
	})
	.style("font-weight",function(d){
		if(d.label=="Ghayour"||d.label=="Elizabeth Rubin"){
			return 400
		}
	})
	.attr("id",function(d){return "_"+cleanString(d.label)})
	
	
	svg.selectAll(".nodes")
	.data(data)
	.enter()
	.append("text")
	.style("font-size","12px")
	.text(function(d){
		if(d.type=="blank"){
			return ""
		}else{
			return d.label
		}
	})
	.attr("x",function(d){
		return d.x*cellSize
	})
	.style("text-anchor","middle")
	.attr("y",function(d){
		return d.y*cellSize+3
	})
	.style("font-size",function(d){
		if(d.label=="Ghayour"){//}||d.label=="Elizabeth Rubin"){
			return "18px"
		}else if(d.type=="group"){
			return "18px"
		}
		else if(d.type=="city"){
			return "24px"
		}
	})
	.style("font-style",function(d){
		if(d.type=="group"){
					return "italic"
				}
	})
	.style("font-weight",function(d){
		if(d.label=="Ghayour"||d.label=="Elizabeth Rubin"){
			return 400
		}
	})
	.attr("id",function(d){return "_"+cleanString(d.label)})
	

	
		// svg.selectAll(".nodesMarkers")
	// 	.data(data)
	// 	.enter()
	// 	.append("circle")
	// 	// .attr("d",function(d){
	// // 		console.log(d.type)
	// // 		return triangle
	// // 	})
	// 		.attr("r",function(d){
	// 			if(d.label=="Ghayour"){//}||d.label=="Elizabeth Rubin"){
	// 				return 5
	// 			}else{
	// 				return 3
	// 			}
	// 		})
	// 	// .attr("transform",
	// 	// 	function(d){
	// 	// 		return 	"translate("+d.coords.split(",")[0]*cellSize+","+d.coords.split(",")[1]*cellSize+")"
	// 	// 	}
	// 	// )
	// 	 .attr("cx",function(d){
	//  		return d.coords.split(",")[0]*cellSize
	//  	})
	//  	.attr("cy",function(d){
	//  		return d.coords.split(",")[1]*cellSize
	//  	})
}
  
  // This function will animate the path over and over again
function blobs(pathData,divName) {
  // Add the line
  var path = svg.append("path")
      .attr("d", pathData)// line(data))
      .attr("fill", "none")
      .attr("stroke-width", 1)
      .attr("stroke", "black")
	  .attr("id",divName)
	
  
  // Get the length of the path, which we will use for the intial offset to "hide"
  // the graph
  var pathLength = path.node().getTotalLength();
  console.log(pathLength)
  
  path.attr("pathLength",pathLength)
    // Animate the path by setting the initial offset and dasharray and then transition the offset to 0
    path.attr("stroke-dasharray", pathLength + " " + pathLength)
      //  .attr("stroke-dashoffset", pathLength)
          // .transition()
        //   .ease(d3.easeLinear)
          .attr("stroke-dashoffset",pathLength)// pathLength)//newScrollTop/pathLength*pathLength)
  
          // .duration(pathData.length*20)
 //          .on("end", function(d){
 //          	d3.select(this).style("fill","red").attr("fill-opacity",.2)
 //          }); // this will repeat the animation after waiting 1 second
    
};
  
function setOpacityNodes(chapter){
	console.log(chapter)
	for(var i in nodeData){
		if(parseInt(nodeData[i].chapter)<=chapter){
			console.log(nodeId)
			if(nodeData[i].label!=undefined){
				var nodeId = cleanString(nodeData[i].label)
				d3.selectAll("#_"+nodeId).style("opacity",1)
			}
		}else{
			if(nodeData[i].label!=undefined){
				var nodeId = cleanString(nodeData[i].label)
				d3.selectAll("#_"+nodeId).style("opacity",0)
			}
		}
	}
}

function transitionLinks(chapter){
	// console.log(nodeCoordsDictionary)
// 	console.log(chapter)
	for(var i in linkData){
		if(linkData[i].source!=undefined){
			var source = linkData[i].source
			var target = linkData[i].target
		//	console.log(source,target)
			var linkId = "_"+cleanString(source)+"_"+cleanString(target)
			//console.log(linkId)
		
			var linkChapter = parseInt(nodeCoordsDictionary[cleanString(target)].chapter)+1
		//	console.log(linkChapter)
			
			var pathLength = d3.select("#"+linkId).attr("pathLength")
			if(linkChapter<chapter){
			//	console.log(scrollTop)
				//if showing chpater, then show just the whole line
				d3.selectAll("#"+linkId).style("opacity",1).transition().duration(1000).attr("stroke-dashoffset",0)
			}else if(linkChapter==chapter){
				//show the percentage of the line that is scrolled through
				var percentScroll = panelSize/(scrollTop-(chapter-1)*panelSize)
				// console.log(percentScroll)
// 				console.log(scrollTop)
				d3.selectAll("#"+linkId).transition().ease(d3.easeLinear)
				.attr("stroke-dashoffset",0)
			}else{
				//show no line, transition to none
				d3.selectAll("#"+linkId).transition()
				.attr("stroke-dashoffset",pathLength)//.style("opacity",0)
			
			}
		}
		
		
	}
}

function step0(){
	setOpacityNodes(0)
    console.log("do step0")
  //  blobs(path2,"path2");
}

function step1(){
	setOpacityNodes(6)
    console.log("do step1")
   // blobs(path3,"path3");
}

function step2(){
	setOpacityNodes(15)
    console.log("do step2")    
  //  blobs(path4,"path4");
}
function step3(){
	setOpacityNodes(20)
    console.log("do step3")
    //blobs(path1,"path1");
}
function step4(){
	setOpacityNodes(30)
    console.log("do step4")
    //blobs(path1,"path1");
}
function step5(){
	setOpacityNodes(40)
    console.log("do step5")
    //blobs(path1,"path1");
}


//here we list all the functions we have above, but just the names without the parenthesis so we don't trigger the functions now
var listOfStepFunctions =[step0,step1,step2,step3,step4,step5]


//whenever the container scrolls, we need to get how far it has scrolled and save it to the variable newScrollTop
d3.select('#container')
.on("scroll.scroller", function() {
    newScrollTop = d3.select('#container').node().scrollTop
	var chapter = Math.floor(scrollTop/panelSize)
	//console.log(newScrollTop)
		//
	// d3.select("#path2").attr("stroke-dashoffset", newScrollTop)
	// d3.select("#path3").attr("stroke-dashoffset", newScrollTop)
	// d3.select("#path").attr("stroke-dashoffset", newScrollTop)
	// d3.select("#path4").attr("stroke-dashoffset", newScrollTop)
		//
	// blobTransitions("#path2", newScrollTop)
	// blobTransitions("#path3", newScrollTop)
});

function blobTransitions(blobId, scrolltop){
	var pathLength = d3.select(blobId).attr("pathLength")
	//console.log(pathLength)
	//.attr("stroke-dasharray",pathLength+" "+pathLength)
	
	if(scrolltop>pathLength){
		d3.select(blobId).attr("fill",fillColors[0]).attr("opacity",.2)
	}else{
		d3.select(blobId).attr("fill","none")
		d3.select(blobId).attr("stroke-dashoffset",pathLength-(scrolltop%pathLength))
	}
}


//the render function ties everything together
function render(){
//each panel is the size of the window height
    
  if (scrollTop !== newScrollTop) {//if the scroller has moved
      
      if(scrollTop<newScrollTop){//if the new value is smaller, then it is scrolling down
          scrollTop = newScrollTop//set the scroller place to its new placement
          //console.log("down")//if it is going down, we need to add 1 to the panel number because we want to trigger the next panel
          var panelNumber = Math.round(scrollTop/panelSize)+1//therefore which panel we are on is the scroller's place divided by panel height
      }else{
          //console.log("up")
          scrollTop = newScrollTop//set the scroller place to its new placement
          var panelNumber = Math.round(scrollTop/panelSize)//therefore which panel we are on is the scroller's place divided by panel height
      }
      
      if(panel!=panelNumber){//if this panel number has changed
          panel = panelNumber//set the panel number to this new number so we can keep track
		  setOpacityNodes(panel)
		  transitionLinks(panel)
	transitionLinks(panel)
		  
		  d3.selectAll(".panel").style("opacity",.2)
		  d3.select("#panel_"+(panel-1)).style("opacity",1)
       //   listOfStepFunctions[panel]()//do the function that is associated with that panel number, we add the () to the end of the name to trigger the function
      }
    currentScrollTop.text(scrollTop)
  }
  window.requestAnimationFrame(render)//we continue to call this function recursively because we always need to check where the scroller is
}

window.requestAnimationFrame(render)




  
